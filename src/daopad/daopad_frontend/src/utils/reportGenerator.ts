// Security report generation utilities

export function generateMarkdownReport(securityData, tokenSymbol) {
  const {
    decentralization_score,
    overall_status,
    last_checked,
    checks,
    risk_summary,
    critical_issues,
    recommended_actions
  } = securityData;

  const timestamp = new Date(Number(last_checked) / 1000000).toISOString();
  const reportId = generateReportId();

  return `
# Security Audit Report: ${tokenSymbol} DAO

**Generated:** ${timestamp}
**Report ID:** ${reportId}
**Decentralization Score:** ${decentralization_score}%
**Status:** ${getScoreLabel(decentralization_score)}

---

## Executive Summary

${risk_summary}

This report analyzes ${checks.length} security checks across 16 categories to evaluate the DAO's decentralization and identify potential governance bypasses.

### Score Breakdown

- **Score:** ${decentralization_score}/100
- **Status:** ${overall_status}
- **Critical Issues:** ${critical_issues.filter(i => i.severity === 'Critical').length}
- **High Priority Issues:** ${critical_issues.filter(i => i.severity === 'High').length}
- **Total Failed Checks:** ${checks.filter(c => c.status === 'Fail').length}
- **Total Warnings:** ${checks.filter(c => c.status === 'Warn').length}
- **Passing Checks:** ${checks.filter(c => c.status === 'Pass').length}

---

## Critical Issues (${critical_issues.length})

${critical_issues.length === 0 ?
    'No critical issues found. The DAO security configuration is strong.' :
    critical_issues.map((issue, i) => `
### ${i + 1}. ${issue.name}

**Category:** ${issue.category}
**Severity:** ${issue.severity || 'None'}
**Status:** ${issue.status}

#### Problem

${issue.message}

${issue.details ? `#### Details\n\n${issue.details}\n` : ''}

${issue.recommendation ? `#### Recommendation\n\n${issue.recommendation}\n` : ''}

${issue.related_permissions && issue.related_permissions.length > 0 ? `
#### Affected Permissions

${issue.related_permissions.map(perm =>
    `- \`${perm.resource_type}\` granted to: ${perm.groups.join(', ')}`
).join('\n')}
` : ''}

---
`).join('\n')
}

---

## All Security Checks

### By Category

${generateChecksByCategory(checks)}

### Summary Table

| Category | Pass | Warn | Fail | Error |
|----------|------|------|------|-------|
${generateSummaryTable(checks)}

---

## Recommended Actions

${recommended_actions.length === 0 ?
    'No immediate actions required. Continue monitoring security configuration.' :
    recommended_actions.map((action, i) => `${i + 1}. ${action}`).join('\n')
}

---

## Next Steps

1. **Immediate:** Address all Critical issues (${critical_issues.filter(i => i.severity === 'Critical').length} remaining)
2. **High Priority:** Review and fix High severity issues (${critical_issues.filter(i => i.severity === 'High').length} remaining)
3. **Medium Priority:** Evaluate Medium severity warnings
4. **Governance:** Create proposals for permission changes requiring community vote
5. **Validation:** Re-run security audit after implementing fixes

---

## Appendix: Understanding the Score

### Score Ranges

- **85-100%:** TRUE DAO - Full community governance, no bypass paths
- **60-84%:** MOSTLY DECENTRALIZED - Minor issues remain
- **30-59%:** PARTIAL DAO - Significant bypass opportunities exist
- **0-29%:** NOT A DAO - Critical issues prevent community governance

### Severity Levels

- **Critical (-10 to -20 points):** Direct governance bypass, treasury theft possible
- **High (-2 to -5 points):** Indirect bypass paths, significant risk
- **Medium (-1 to -2 points):** Configuration issues, moderate risk
- **Low (-0.5 points):** Minor warnings, low risk

---

*Generated by DAOPad Security Auditor*
*For questions or support, visit https://daopad.xyz*
  `.trim();
}

function getScoreLabel(score) {
  if (score < 30) return 'NOT A DAO';
  if (score < 60) return 'PARTIAL DAO';
  if (score < 85) return 'MOSTLY DECENTRALIZED';
  return 'TRUE DAO';
}

function generateReportId() {
  return `DAOPAD-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
}

function generateChecksByCategory(checks) {
  const categories = {};

  checks.forEach(check => {
    if (!categories[check.category]) {
      categories[check.category] = [];
    }
    categories[check.category].push(check);
  });

  return Object.entries(categories).map(([category, categoryChecks]) => `
#### ${category}

${categoryChecks.map(check =>
    `- **${check.name}** [${check.status}${check.severity && check.severity !== 'None' ? ` - ${check.severity}` : ''}]: ${check.message}`
).join('\n')}
  `).join('\n');
}

function generateSummaryTable(checks) {
  const categories = {};

  checks.forEach(check => {
    if (!categories[check.category]) {
      categories[check.category] = { Pass: 0, Warn: 0, Fail: 0, Error: 0 };
    }
    categories[check.category][check.status]++;
  });

  return Object.entries(categories).map(([category, counts]) =>
    `| ${category} | ${counts.Pass} | ${counts.Warn} | ${counts.Fail} | ${counts.Error} |`
  ).join('\n');
}

export function downloadReport(content, filename, type = 'markdown') {
  const mimeTypes = {
    markdown: 'text/markdown',
    json: 'application/json',
    txt: 'text/plain',
  };

  const blob = new Blob([content], { type: mimeTypes[type] || 'text/plain' });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

export function generateJSONReport(securityData) {
  return JSON.stringify(securityData, null, 2);
}
